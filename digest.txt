Directory structure:
└── Application1/
    ├── main.py
    ├── mainV2.py
    ├── mainV3.py
    └── requirements.txt

================================================
FILE: main.py
================================================
import os
import re  # <--- NOU: Pentru validare format
from fastapi import FastAPI, HTTPException, Query, Body, status
from pydantic import BaseModel, field_validator # <--- MODIFICAT: AdaugÄƒ field_validator
from typing import List, Optional
from dotenv import load_dotenv
from supabase import create_client, Client
from datetime import datetime, timedelta, timezone
from itertools import groupby
from zoneinfo import ZoneInfo
# --- 1. Configurare & Conexiune ---
load_dotenv()

app = FastAPI(
    title="QuickWash API V3",
    description="Backend complet: SpÄƒlÄƒtorii, Boxe (CRUD Nested) È™i RezervÄƒri Smart."
)

SUPABASE_URL: str = os.environ.get("SUPABASE_URL")
SUPABASE_KEY: str = os.environ.get("SUPABASE_KEY")

if not SUPABASE_URL or not SUPABASE_KEY:
    raise RuntimeError("SUPABASE_URL sau SUPABASE_KEY lipsesc din fiÈ™ierul .env")

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)


# ==========================================
# 2. MODELE DE DATE (Pydantic Schemas)
# ==========================================

# --- SpÄƒlÄƒtorii ---
class SpalatorieCreate(BaseModel):
    nume: str
    adresa: Optional[str] = None
    
    # MODIFICAT: Default explicit
    program_functionare: str = "00:00 - 24:00"
    
    latitudine: float
    longitudine: float

    # NOU: Validatorul care previne erorile de format
    @field_validator('program_functionare')
    @classmethod
    def validate_program(cls, v: str) -> str:
        if "non" in v.lower() and "stop" in v.lower():
            return "00:00 - 24:00"
        # VerificÄƒ formatul HH:MM - HH:MM
        pattern = r"^\d{2}:\d{2}\s*-\s*\d{2}:\d{2}$"
        if not re.match(pattern, v.strip()):
            raise ValueError('Format invalid! FoloseÈ™te strict "HH:MM - HH:MM" (ex: 08:00 - 22:00)')
        return v

class SpalatorieResponse(BaseModel):
    id: str
    nume: str
    adresa: Optional[str]
    latitudine: float
    longitudine: float
    distanta_km: Optional[float] = None

# --- Boxe ---
class BoxaBase(BaseModel):
    nume_boxa: str
    pret_rezervare_lei: float = 15.0
    timp_rezervare_minute: int = 60
    is_available: bool = True

class BoxaCreate(BoxaBase):
    # LuÄƒm spalatorie_id din URL, nu din body
    pass

class BoxaUpdate(BaseModel):
    nume_boxa: Optional[str] = None
    pret_rezervare_lei: Optional[float] = None
    timp_rezervare_minute: Optional[int] = None
    is_available: Optional[bool] = None

class BoxaResponse(BoxaBase):
    boxa_id: str
    spalatorie_id: str

# --- RezervÄƒri ---
class RezervareCreate(BaseModel):
    boxa_id: str
    durata_minute: int 
    client_ref: Optional[str] = None

class RezervareResponse(BaseModel):
    rezervare_id: str
    boxa_id: str
    spalatorie_id: str # Important pentru istoric
    ora_start: datetime
    ora_sfarsit: datetime
    status: str
    client_ref: Optional[str]

# Modele pentru disponibilitate
class IntervalLiber(BaseModel):
    start: datetime
    end: datetime
    minute_disponibile: int

class BoxaDisponibila(BaseModel):
    boxa_id: str
    nume_boxa: str
    pret_rezervare_lei: float
    intervale: List[IntervalLiber]

class SpalatorieDisponibilaResponse(BaseModel):
    spalatorie_id: str
    nume: str
    distanta_km: Optional[float] = None
    boxe_libere: List[BoxaDisponibila]

# ==========================================
# 3. LOGICA DE BUSINESS (Helpers)
# ==========================================

# FuncÈ›ie ajutÄƒtoare pentru citirea orelor din formatul "HH:MM - HH:MM"
def parse_schedule(schedule_str: str):
    if not schedule_str or "00:00 - 24:00" in schedule_str:
        return 0, 24
    try:
        parts = schedule_str.split('-')
        start = int(parts[0].strip().split(':')[0])
        end = int(parts[1].strip().split(':')[0])
        return start, end
    except:
        return 0, 24

# Algoritmul complet cu FIX-ul pentru ora de Ã®nchidere la final
def calculeaza_gaps(
    start_window_utc: datetime, 
    end_window_utc: datetime, 
    rezervari: list, 
    durata_minima_minute: int,
    program_str: str = "00:00 - 24:00"
):
    gaps = []
    
    # 1. SetÄƒm fusul orar (RomÃ¢nia)
    try:
        tz_ro = ZoneInfo("Europe/Bucharest")
    except:
        tz_ro = timezone.utc

    # Ora curentÄƒ Ã®n RomÃ¢nia
    now_ro = start_window_utc.astimezone(tz_ro)
    
    # ParsÄƒm programul
    ora_deschidere, ora_inchidere = parse_schedule(program_str)
    
    # 2. AjustÄƒm fereastra de start ("Clamping")
    if now_ro.hour < ora_deschidere:
        # DacÄƒ e prea devreme, startul se mutÄƒ la ora deschiderii
        start_ro_adjusted = now_ro.replace(hour=ora_deschidere, minute=0, second=0)
        start_window_utc = start_ro_adjusted.astimezone(timezone.utc)
    elif now_ro.hour >= ora_inchidere and ora_inchidere != 24:
        # DacÄƒ e prea tÃ¢rziu, nu mai sunt locuri azi
        return [] 

    if start_window_utc >= end_window_utc:
        return []

    current_time = start_window_utc
    
    # SortÄƒm rezervÄƒrile cronologic
    rezervari_sorted = sorted(
        rezervari, 
        key=lambda x: datetime.fromisoformat(x['ora_start'])
    )

    # IterÄƒm prin rezervÄƒri pentru a gÄƒsi spaÈ›ii ÃŽNTRE ele
    for res in rezervari_sorted:
        res_start = datetime.fromisoformat(res['ora_start'])
        res_end = datetime.fromisoformat(res['ora_sfarsit'])

        if res_start > current_time:
            # LogicÄƒ de tÄƒiere la ora Ã®nchiderii
            gap_start_ro = current_time.astimezone(tz_ro)
            limit_end = res_start
            
            if ora_inchidere != 24:
                ora_inchidere_azi = gap_start_ro.replace(hour=ora_inchidere, minute=0, second=0).astimezone(timezone.utc)
                # DacÄƒ rezervarea urmÄƒtoare Ã®ncepe DUPÄ‚ Ã®nchidere, tÄƒiem gap-ul la Ã®nchidere
                if limit_end > ora_inchidere_azi:
                    limit_end = ora_inchidere_azi
            
            if limit_end > current_time:
                gap_duration = (limit_end - current_time).total_seconds() / 60
                if gap_duration >= durata_minima_minute:
                    gaps.append({
                        "start": current_time,
                        "end": limit_end,
                        "minute_disponibile": int(gap_duration)
                    })

        if res_end > current_time:
            current_time = res_end

    # 3. Gap final (dupÄƒ ultima rezervare pÃ¢nÄƒ la finalul ferestrei cerute)
    if current_time < end_window_utc:
        limit_end = end_window_utc
        
        # FIX APLICAT AICI: VerificÄƒm programul de Ã®nchidere pentru gap-ul final
        if ora_inchidere != 24:
             gap_start_ro = current_time.astimezone(tz_ro)
             ora_inchidere_azi = gap_start_ro.replace(hour=ora_inchidere, minute=0, second=0).astimezone(timezone.utc)
             
             # DacÄƒ fereastra cerutÄƒ se terminÄƒ DUPÄ‚ Ã®nchidere, tÄƒiem la ora Ã®nchiderii
             if limit_end > ora_inchidere_azi:
                 limit_end = ora_inchidere_azi

        # Doar dacÄƒ a mai rÄƒmas timp valid dupÄƒ tÄƒiere, adÄƒugÄƒm gap-ul
        if limit_end > current_time:
            gap_duration = (limit_end - current_time).total_seconds() / 60
            if gap_duration >= durata_minima_minute:
                gaps.append({
                    "start": current_time,
                    "end": limit_end,
                    "minute_disponibile": int(gap_duration)
                })
            
    return gaps

# ==========================================
# 3. RUTE API (Endpoints)
# ==========================================

@app.get("/", summary="Health Check")
def read_root():
    return {"status": "QuickWash API este live!"}

# ---------------------------
# A. SPÄ‚LÄ‚TORII
# ---------------------------

@app.post("/spalatorii", status_code=status.HTTP_201_CREATED, summary="AdaugÄƒ SpÄƒlÄƒtorie")
def add_spalatorie(spalatorie: SpalatorieCreate = Body(...)):
    try:
        data = spalatorie.model_dump()
        response = supabase.table('spalatorii').insert({
            "nume": data['nume'],
            "adresa": data['adresa'],
            "program_functionare": data['program_functionare'],
            "locatie": f"SRID=4326;POINT({data['longitudine']} {data['latitudine']})"
        }).execute()

        if response.data:
            return response.data[0]
        raise HTTPException(status_code=500, detail="Eroare la salvare.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/spalatorii-apropiate", response_model=List[SpalatorieResponse], summary="CÄƒutare Geo")
def get_spalatorii_apropiate(
    lat: float = Query(..., description="Lat user"),
    lon: float = Query(..., description="Lon user"),
    raza_km: float = Query(5.0, description="Raza Ã®n km")
):
    try:
        response = supabase.rpc(
            'gaseste_apropiate',
            {'user_lat': lat, 'user_lon': lon, 'raza_km': raza_km}
        ).execute()
        
        if response.data:
            return [SpalatorieResponse(**item) for item in response.data]
        return []
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Eroare server: {str(e)}")


# ---------------------------
# B. BOXE (Nested Routes)
# ---------------------------

@app.get("/spalatorii/{spalatorie_id}/boxe", response_model=List[BoxaResponse])
def get_boxe_spalatorie(spalatorie_id: str):
    try:
        response = supabase.table('boxe').select('*').eq('spalatorie_id', spalatorie_id).execute()
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/spalatorii/{spalatorie_id}/boxe/{boxa_id}", response_model=BoxaResponse)
def get_single_boxa(spalatorie_id: str, boxa_id: str):
    try:
        response = supabase.table('boxe').select('*')\
            .eq('boxa_id', boxa_id)\
            .eq('spalatorie_id', spalatorie_id)\
            .execute()
        
        if response.data:
            return response.data[0]
        raise HTTPException(status_code=404, detail="Boxa nu a fost gÄƒsitÄƒ.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/spalatorii/{spalatorie_id}/boxe", status_code=status.HTTP_201_CREATED, response_model=BoxaResponse)
def adauga_boxa(spalatorie_id: str, boxa: BoxaCreate = Body(...)):
    try:
        insert_data = boxa.model_dump()
        insert_data['spalatorie_id'] = spalatorie_id
        
        response = supabase.table('boxe').insert(insert_data).execute()
        
        if response.data:
            return response.data[0]
        raise HTTPException(status_code=500, detail="Eroare la creare.")
    except Exception as e:
        if "foreign key" in str(e):
            raise HTTPException(status_code=404, detail="SpÄƒlÄƒtoria nu existÄƒ.")
        raise HTTPException(status_code=500, detail=str(e))

@app.patch("/spalatorii/{spalatorie_id}/boxe/{boxa_id}", response_model=BoxaResponse)
def update_boxa(spalatorie_id: str, boxa_id: str, boxa_update: BoxaUpdate):
    try:
        update_data = boxa_update.model_dump(exclude_unset=True)
        if not update_data:
            raise HTTPException(status_code=400, detail="FÄƒrÄƒ date de update.")

        response = supabase.table('boxe').update(update_data)\
            .eq('boxa_id', boxa_id)\
            .eq('spalatorie_id', spalatorie_id)\
            .execute()
        
        if response.data:
            return response.data[0]
        raise HTTPException(status_code=404, detail="Boxa nu existÄƒ.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/spalatorii/{spalatorie_id}/boxe/{boxa_id}", status_code=status.HTTP_204_NO_CONTENT)
def sterge_boxa(spalatorie_id: str, boxa_id: str):
    try:
        response = supabase.table('boxe').delete()\
            .eq('boxa_id', boxa_id)\
            .eq('spalatorie_id', spalatorie_id)\
            .execute()
        if not response.data:
             raise HTTPException(status_code=404, detail="Boxa nu a fost gÄƒsitÄƒ.")
        return None
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# ---------------------------
# C. REZERVÄ‚RI (Smart Logic)
# ---------------------------

@app.post("/rezervari", status_code=status.HTTP_201_CREATED, response_model=RezervareResponse)
def creare_rezervare(rezervare: RezervareCreate):
    """
    CreeazÄƒ o rezervare. 
    CompleteazÄƒ automat ID-ul spÄƒlÄƒtoriei pentru istoric.
    """
    try:
        # 1. CÄƒutÄƒm ID-ul spÄƒlÄƒtoriei (PÄƒrintele boxei)
        boxa_info = supabase.table('boxe').select('spalatorie_id').eq('boxa_id', rezervare.boxa_id).execute()
        
        if not boxa_info.data:
            raise HTTPException(status_code=404, detail="Boxa specificatÄƒ nu existÄƒ.")
            
        real_spalatorie_id = boxa_info.data[0]['spalatorie_id']

        # 2. CalculÄƒm timpii
        start = datetime.now(timezone.utc)
        sfarsit = start + timedelta(minutes=rezervare.durata_minute)
        
        # 3. InserÄƒm cu TOATE datele necesare
        data_insert = {
            "boxa_id": rezervare.boxa_id,
            "spalatorie_id": real_spalatorie_id, # Completat automat
            "ora_start": start.isoformat(),
            "ora_sfarsit": sfarsit.isoformat(),
            "client_ref": rezervare.client_ref,
            "status": "activa"
        }

        response = supabase.table('rezervari').insert(data_insert).execute()
        
        if response.data:
            return response.data[0]
        raise HTTPException(status_code=500, detail="Eroare server.")

    except Exception as e:
        # Prindem eroarea de suprapunere (Exclusion Constraint)
        if "conflicting key" in str(e) or "exclusion constraint" in str(e):
            raise HTTPException(status_code=409, detail="Boxa este deja ocupatÄƒ Ã®n acest moment!")
        raise HTTPException(status_code=500, detail=str(e))


@app.patch("/rezervari/{rezervare_id}/checkout", response_model=RezervareResponse)
def early_checkout(rezervare_id: str):
    """
    ElibereazÄƒ boxa mai devreme.
    """
    try:
        now = datetime.now(timezone.utc).isoformat()
        
        response = supabase.table('rezervari').update({
            "ora_sfarsit": now,
            "status": "finalizata"
        }).eq('rezervare_id', rezervare_id).execute()
        
        if response.data:
            return response.data[0]
        raise HTTPException(status_code=404, detail="Rezervarea nu a fost gÄƒsitÄƒ.")
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/rezervari/active", response_model=List[RezervareResponse])
def get_rezervari_active():
    try:
        response = supabase.table('rezervari').select('*').eq('status', 'activa').execute()
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

#DISPONIBILITATE BOXE È˜I SPÄ‚LÄ‚TORII
@app.get("/spalatorii/{spalatorie_id}/disponibilitate", response_model=List[BoxaDisponibila])
def get_disponibilitate_spalatorie(
    spalatorie_id: str,
    durata_dorita_min: int = Query(30, description="CÃ¢t timp vrei sÄƒ speli?"),
    fereastra_ore: int = Query(2, description="CÃ¢t de departe Ã®n viitor cÄƒutÄƒm?")
):
    """
    ReturneazÄƒ intervalele orare disponibile pentru toate boxele unei spÄƒlÄƒtorii
    Ã®n urmÄƒtoarele X ore (default 2).
    """
    try:
        # 1. Definim fereastra de timp (Acum -> Acum + 2h)
        now = datetime.now(timezone.utc)
        end_window = now + timedelta(hours=fereastra_ore)

        # 2. LuÄƒm toate boxele spÄƒlÄƒtoriei
        boxe = supabase.table('boxe').select('*').eq('spalatorie_id', spalatorie_id).eq('is_available', True).execute()
        if not boxe.data:
            return [] # Nicio boxÄƒ funcÈ›ionalÄƒ

        # 3. LuÄƒm toate rezervÄƒrile ACTIVE din acest interval pentru aceastÄƒ spÄƒlÄƒtorie
        # FiltrÄƒm sÄƒ se intersecteze cu fereastra noastrÄƒ
        rezervari = supabase.table('rezervari')\
            .select('boxa_id, ora_start, ora_sfarsit')\
            .eq('spalatorie_id', spalatorie_id)\
            .eq('status', 'activa')\
            .gte('ora_sfarsit', now.isoformat())\
            .lte('ora_start', end_window.isoformat())\
            .execute()
        
        rezervari_list = rezervari.data

        rezultat = []

        # 4. Pentru fiecare boxÄƒ, calculÄƒm golurile
        for boxa in boxe.data:
            # FiltrÄƒm rezervÄƒrile doar pentru boxa curentÄƒ
            rezervari_boxa = [r for r in rezervari_list if r['boxa_id'] == boxa['boxa_id']]
            
            gaps = calculeaza_gaps(now, end_window, rezervari_boxa, durata_dorita_min)
            
            if gaps:
                rezultat.append({
                    "boxa_id": boxa['boxa_id'],
                    "nume_boxa": boxa['nume_boxa'],
                    "pret_rezervare_lei": boxa['pret_rezervare_lei'],
                    "intervale": gaps
                })

        return rezultat

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/spalatorii-apropiate/disponibilitate", response_model=List[SpalatorieDisponibilaResponse])
def get_spalatorii_apropiate_disponibile(
    lat: float,
    lon: float,
    raza_km: float = 5.0,
    durata_dorita_min: int = 30
):
    """
    Cea mai complexÄƒ rutÄƒ:
    1. GÄƒseÈ™te spÄƒlÄƒtoriile apropiate.
    2. Pentru fiecare, verificÄƒ dacÄƒ are MÄ‚CAR O BOXÄ‚ liberÄƒ ACUM (sau Ã®n curÃ¢nd).
    """
    try:
        # 1. GÄƒsim spÄƒlÄƒtoriile fizice (Geospatial)
        locatii = supabase.rpc(
            'gaseste_apropiate',
            {'user_lat': lat, 'user_lon': lon, 'raza_km': raza_km}
        ).execute()
        
        if not locatii.data:
            return []

        spalatorii_ids = [s['id'] for s in locatii.data]
        
        # 2. Definim fereastra (UrmÄƒtoarele 2 ore e standardul nostru)
        now = datetime.now(timezone.utc)
        end_window = now + timedelta(hours=2)

        # 3. LuÄƒm BULK toate boxele È™i rezervÄƒrile pentru aceste spÄƒlÄƒtorii
        boxe_all = supabase.table('boxe').select('*').in_('spalatorie_id', spalatorii_ids).eq('is_available', True).execute()
        
        rezervari_all = supabase.table('rezervari')\
            .select('*')\
            .in_('spalatorie_id', spalatorii_ids)\
            .eq('status', 'activa')\
            .gte('ora_sfarsit', now.isoformat())\
            .lte('ora_start', end_window.isoformat())\
            .execute()

        # 4. ProcesÄƒm datele Ã®n Python
        rezultat_final = []

        for loc in locatii.data:
            # MODIFICARE AICI: Extragem programul din rezultatele RPC
            program = loc.get('program_functionare', "00:00 - 24:00")
            if not program: program = "00:00 - 24:00"

            # GÄƒsim boxele acestei locaÈ›ii
            boxe_locatie = [b for b in boxe_all.data if b['spalatorie_id'] == loc['id']]
            boxe_cu_gaps = []

            for boxa in boxe_locatie:
                # GÄƒsim rezervÄƒrile acestei boxe
                rez_boxa = [r for r in rezervari_all.data if r['boxa_id'] == boxa['boxa_id']]
                
                # MODIFICARE AICI: PasÄƒm program_str cÄƒtre algoritm
                gaps = calculeaza_gaps(now, end_window, rez_boxa, durata_dorita_min, program_str=program)
                
                if gaps:
                    boxe_cu_gaps.append({
                        "boxa_id": boxa['boxa_id'],
                        "nume_boxa": boxa['nume_boxa'],
                        "pret_rezervare_lei": boxa['pret_rezervare_lei'],
                        "intervale": gaps
                    })
            
            # AdÄƒugÄƒm spÄƒlÄƒtoria Ã®n listÄƒ DOAR dacÄƒ are boxe disponibile
            if boxe_cu_gaps:
                rezultat_final.append({
                    "spalatorie_id": loc['id'],
                    "nume": loc['nume'],
                    "distanta_km": loc['distanta_km'],
                    "boxe_libere": boxe_cu_gaps
                })

        return rezultat_final

    except Exception as e:
        print(f"Eroare: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- Ruta DetaliatÄƒ: Disponibilitate per SpÄƒlÄƒtorie ---

@app.get("/spalatorii/{spalatorie_id}/disponibilitate", response_model=List[BoxaDisponibila])
def get_disponibilitate_spalatorie(
    spalatorie_id: str,
    durata_dorita_min: int = Query(30, description="CÃ¢t timp vrei sÄƒ speli?"),
    fereastra_ore: int = Query(2, description="CÃ¢t de departe Ã®n viitor cÄƒutÄƒm?")
):
    """
    ReturneazÄƒ intervalele orare disponibile pentru TOATE boxele unei spÄƒlÄƒtorii specifice.
    """
    try:
        now = datetime.now(timezone.utc)
        end_window = now + timedelta(hours=fereastra_ore)

        # MODIFICARE AICI: LuÄƒm programul spÄƒlÄƒtoriei din DB
        spalatorie_query = supabase.table('spalatorii').select('program_functionare').eq('id', spalatorie_id).execute()
        program = "00:00 - 24:00"
        if spalatorie_query.data:
            program = spalatorie_query.data[0].get('program_functionare', "00:00 - 24:00")
            if not program: program = "00:00 - 24:00"

        # 1. LuÄƒm boxele active ale spÄƒlÄƒtoriei
        boxe = supabase.table('boxe').select('*')\
            .eq('spalatorie_id', spalatorie_id)\
            .eq('is_available', True)\
            .execute()
            
        if not boxe.data:
            return []

        # 2. LuÄƒm rezervÄƒrile active pentru aceastÄƒ spÄƒlÄƒtorie
        rezervari = supabase.table('rezervari')\
            .select('boxa_id, ora_start, ora_sfarsit')\
            .eq('spalatorie_id', spalatorie_id)\
            .eq('status', 'activa')\
            .gte('ora_sfarsit', now.isoformat())\
            .lte('ora_start', end_window.isoformat())\
            .execute()
        
        rezervari_list = rezervari.data
        rezultat = []

        # 3. CalculÄƒm golurile pentru fiecare boxÄƒ
        for boxa in boxe.data:
            rez_boxa = [r for r in rezervari_list if r['boxa_id'] == boxa['boxa_id']]
            
            # MODIFICARE AICI: PasÄƒm programul extras mai sus
            gaps = calculeaza_gaps(now, end_window, rez_boxa, durata_dorita_min, program_str=program)
            
            if gaps:
                rezultat.append({
                    "boxa_id": boxa['boxa_id'],
                    "nume_boxa": boxa['nume_boxa'],
                    "pret_rezervare_lei": boxa['pret_rezervare_lei'],
                    "intervale": gaps
                })

        return rezultat

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


================================================
FILE: mainV2.py
================================================
import os
import re
from fastapi import FastAPI, HTTPException, Query, Body, status
from pydantic import BaseModel, field_validator
from typing import List, Optional
from dotenv import load_dotenv
from supabase import create_client, Client
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo # NecesitÄƒ Python 3.9+
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi import Depends
# --- 1. Configurare & Conexiune ---
load_dotenv()

app = FastAPI(
    title="QuickWash MVP",
    description="Backend Final: FÄƒrÄƒ Auth, Rezervare Smart, Validare Program."
)

# Permitem oricÄƒrui frontend (Bolt, Localhost) sÄƒ acceseze API-ul
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ÃŽn producÈ›ie pui doar domeniul tÄƒu, pt dev lÄƒsÄƒm "*"
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

SUPABASE_URL: str = os.environ.get("SUPABASE_URL")
SUPABASE_KEY: str = os.environ.get("SUPABASE_KEY")

if not SUPABASE_URL or not SUPABASE_KEY:
    raise RuntimeError("SUPABASE_URL sau SUPABASE_KEY lipsesc din fiÈ™ierul .env")

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# --- SECURITATE (Portarul) ---
security = HTTPBearer()

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """ 
    VerificÄƒ dacÄƒ userul este logat. 
    PrimeÈ™te token-ul din Frontend, Ã®l trimite la Supabase È™i returneazÄƒ User-ul real.
    """
    token = credentials.credentials
    try:
        # ÃŽntrebÄƒm Supabase: "E bun token-ul Äƒsta?"
        user_response = supabase.auth.get_user(token)
        
        if not user_response.user:
            raise HTTPException(status_code=401, detail="Token invalid sau expirat.")
            
        return user_response.user
    except Exception as e:
        # DacÄƒ Supabase zice nu, aruncÄƒm eroare 401 (Unauthorized)
        raise HTTPException(status_code=401, detail="Trebuie sÄƒ fii logat pentru a face asta.")

# ==========================================
# 2. MODELE DE DATE (Pydantic Schemas)
# ==========================================

# --- SpÄƒlÄƒtorii ---
class SpalatorieCreate(BaseModel):
    nume: str
    adresa: Optional[str] = None
    
    # ValidÄƒm formatul programului
    program_functionare: str = "00:00 - 24:00"
    
    latitudine: float
    longitudine: float

    @field_validator('program_functionare')
    @classmethod
    def validate_program(cls, v: str) -> str:
        if "non" in v.lower() and "stop" in v.lower():
            return "00:00 - 24:00"
        
        pattern = r"^\d{2}:\d{2}\s*-\s*\d{2}:\d{2}$"
        if not re.match(pattern, v.strip()):
            raise ValueError('Format invalid! FoloseÈ™te strict "HH:MM - HH:MM" (ex: 08:00 - 22:00)')
        return v

# --- Boxe ---
class BoxaBase(BaseModel):
    nume_boxa: str
    pret_rezervare_lei: float = 15.0
    timp_rezervare_minute: int = 60
    is_available: bool = True

class BoxaCreate(BoxaBase):
    pass

class BoxaUpdate(BaseModel):
    nume_boxa: Optional[str] = None
    pret_rezervare_lei: Optional[float] = None
    timp_rezervare_minute: Optional[int] = None
    is_available: Optional[bool] = None

class BoxaResponse(BoxaBase):
    boxa_id: str
    spalatorie_id: str

# --- RezervÄƒri (FÄƒrÄƒ User ID) ---
class RezervareCreate(BaseModel):
    boxa_id: str
    durata_minute: int 
    # OBLIGATORIU: Telefon sau Nr. ÃŽnmatriculare (Identitatea clientului)
    client_ref: str 

class RezervareResponse(BaseModel):
    rezervare_id: str
    boxa_id: str
    spalatorie_id: str
    ora_start: datetime
    ora_sfarsit: datetime
    status: str
    client_ref: str

# --- Modele pentru disponibilitate ---
class IntervalLiber(BaseModel):
    start: datetime
    end: datetime
    minute_disponibile: int

# ACEASTA TREBUIE SÄ‚ FIE PRIMA
class BoxaDisponibila(BaseModel):
    boxa_id: str
    nume_boxa: str
    pret_rezervare_lei: float
    intervale: List[IntervalLiber]

# ACEASTA O FOLOSEÈ˜TE PE CEA DE MAI SUS
class SpalatorieDisponibilaResponse(BaseModel):
    spalatorie_id: str
    nume: str
    program_functionare: str
    distanta_km: Optional[float] = None
    latitudine: float
    longitudine: float
    boxe_libere: List[BoxaDisponibila]


# ==========================================
# 3. LOGICA DE BUSINESS (Helpers & Algoritmi)
# ==========================================

def parse_schedule(schedule_str: str):
    """ Extrage orele (int) din string. """
    if not schedule_str or "00:00 - 24:00" in schedule_str:
        return 0, 24
    try:
        parts = schedule_str.split('-')
        start = int(parts[0].strip().split(':')[0])
        end = int(parts[1].strip().split(':')[0])
        return start, end
    except:
        return 0, 24 

def calculeaza_gaps(
    start_window_utc: datetime, 
    end_window_utc: datetime, 
    rezervari: list, 
    durata_minima_minute: int,
    program_str: str = "00:00 - 24:00"
):
    gaps = []
    
    # 1. Ora RomÃ¢niei (Manual Offset pentru siguranÈ›Äƒ pe Render)
    RO_OFFSET = timezone(timedelta(hours=2)) 
    now_ro = start_window_utc.astimezone(RO_OFFSET)
    
    ora_deschidere, ora_inchidere = parse_schedule(program_str)
    
    # 2. DeterminÄƒm intervalele de funcÈ›ionare pentru "AZI"
    # Un program poate fi continuu (8-20) sau spart de miezul nopÈ›ii (10-02)
    open_intervals = [] # Lista de tupluri (start_hour, end_hour)
    
    if ora_deschidere < ora_inchidere:
        # Program normal (ex: 08:00 - 22:00)
        open_intervals.append((ora_deschidere, ora_inchidere))
    elif ora_deschidere > ora_inchidere:
        # Program peste noapte (ex: 10:00 - 02:00)
        # Interval 1: 00:00 - 02:00 (dimineaÈ›a devreme)
        open_intervals.append((0, ora_inchidere))
        # Interval 2: 10:00 - 24:00 (ziua È™i seara)
        open_intervals.append((ora_deschidere, 24))
    else:
        # Non-stop sau 00-24 sau 08-08
        open_intervals.append((0, 24))

    # 3. VerificÄƒm dacÄƒ suntem Ã®ntr-un interval deschis ACUM
    # Sau ajustÄƒm startul la urmÄƒtorul interval deschis
    adjusted_start_utc = None
    current_hour = now_ro.hour + (now_ro.minute / 60)
    
    is_open_now = False
    next_open_hour = None
    
    # CÄƒutÄƒm unde ne Ã®ncadrÄƒm
    for (start_h, end_h) in open_intervals:
        # Suntem Ã®n interval?
        if start_h <= current_hour < end_h:
            is_open_now = True
            # Limita de Ã®nchidere curentÄƒ
            current_closing_hour = end_h
            break
        
        # DacÄƒ nu suntem, care e urmÄƒtorul start?
        if start_h > current_hour:
            if next_open_hour is None or start_h < next_open_hour:
                next_open_hour = start_h
                current_closing_hour = end_h

    if is_open_now:
        # Suntem deschiÈ™i, pÄƒstrÄƒm ora curentÄƒ
        adjusted_start_utc = start_window_utc
    elif next_open_hour is not None:
        # Suntem Ã®nchiÈ™i, dar deschidem mai tÃ¢rziu azi
        # AjustÄƒm startul la ora deschiderii
        target_h = int(next_open_hour)
        target_m = int((next_open_hour - target_h) * 60)
        start_ro_adjusted = now_ro.replace(hour=target_h, minute=target_m, second=0)
        adjusted_start_utc = start_ro_adjusted.astimezone(timezone.utc)
    else:
        # S-a Ã®nchis pe ziua de azi (È™i nu mai deschide pÃ¢nÄƒ la 24:00)
        return []

    # VerificÄƒm dacÄƒ ajustarea a depÄƒÈ™it fereastra de cÄƒutare
    if adjusted_start_utc >= end_window_utc:
        return []

    # SetÄƒm cursorul
    current_time = adjusted_start_utc
    
    # 4. Calculul efectiv al gÄƒurilor (Iterare printre rezervÄƒri)
    rezervari_sorted = sorted(
        rezervari, 
        key=lambda x: datetime.fromisoformat(x['ora_start'])
    )

    for res in rezervari_sorted:
        res_start = datetime.fromisoformat(res['ora_start'])
        res_end = datetime.fromisoformat(res['ora_sfarsit'])

        if res_start > current_time:
            # Avem un potenÈ›ial gap. Trebuie sÄƒ Ã®l tÄƒiem la ora Ã®nchiderii curente
            # 'current_closing_hour' e ora la care se terminÄƒ tura curentÄƒ (ex: 22:00 sau 02:00 sau 24:00)
            
            gap_start_ro = current_time.astimezone(RO_OFFSET)
            limit_end = res_start
            
            # CalculÄƒm timestamp-ul orei de Ã®nchidere pentru AZI
            if current_closing_hour != 24:
                h_close = int(current_closing_hour)
                m_close = int((current_closing_hour - h_close) * 60)
                
                # AtenÈ›ie: dacÄƒ ora de Ã®nchidere e mÃ¢ine (teoretic nu ajungem aici pt cÄƒ am spart intervalele pe zile)
                # Dar pentru siguranÈ›Äƒ, folosim data curentÄƒ a gap-ului
                ora_inchidere_azi_ro = gap_start_ro.replace(hour=h_close, minute=m_close, second=0)
                ora_inchidere_azi_utc = ora_inchidere_azi_ro.astimezone(timezone.utc)
                
                if limit_end > ora_inchidere_azi_utc:
                    limit_end = ora_inchidere_azi_utc
            
            if limit_end > current_time:
                gap_duration = (limit_end - current_time).total_seconds() / 60
                if gap_duration >= durata_minima_minute:
                    gaps.append({
                        "start": current_time,
                        "end": limit_end,
                        "minute_disponibile": int(gap_duration)
                    })

        if res_end > current_time:
            current_time = res_end

    # 5. Gap Final
    if current_time < end_window_utc:
        limit_end = end_window_utc
        
        # TÄƒiere finalÄƒ la Ã®nchidere
        gap_start_ro = current_time.astimezone(RO_OFFSET)
        if current_closing_hour != 24:
            h_close = int(current_closing_hour)
            m_close = int((current_closing_hour - h_close) * 60)
            ora_inchidere_azi_ro = gap_start_ro.replace(hour=h_close, minute=m_close, second=0)
            ora_inchidere_azi_utc = ora_inchidere_azi_ro.astimezone(timezone.utc)
            
            if limit_end > ora_inchidere_azi_utc:
                limit_end = ora_inchidere_azi_utc
        
        if limit_end > current_time:
            gap_duration = (limit_end - current_time).total_seconds() / 60
            if gap_duration >= durata_minima_minute:
                gaps.append({
                    "start": current_time,
                    "end": limit_end,
                    "minute_disponibile": int(gap_duration)
                })
            
    return gaps

# ==========================================
# 4. RUTE API (Endpoints)
# ==========================================

@app.get("/", summary="Health Check")
def read_root():
    return {"status": "QuickWash API este live!"}

# --- A. SPÄ‚LÄ‚TORII ---

@app.post("/spalatorii", status_code=status.HTTP_201_CREATED)
def add_spalatorie(spalatorie: SpalatorieCreate = Body(...)):
    try:
        data = spalatorie.model_dump()
        response = supabase.table('spalatorii').insert({
            "nume": data['nume'],
            "adresa": data['adresa'],
            "program_functionare": data['program_functionare'],
            "locatie": f"SRID=4326;POINT({data['longitudine']} {data['latitudine']})"
        }).execute()
        if response.data: return response.data[0]
        raise HTTPException(status_code=500, detail="Eroare salvare.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/spalatorii-apropiate/disponibilitate", response_model=List[SpalatorieDisponibilaResponse])
def get_spalatorii_apropiate_disponibile(
    lat: float, lon: float, raza_km: float = 5.0, durata_dorita_min: int = 30
):
    try:
        # 1. CÄƒutare Geo (RPC)
        locatii = supabase.rpc('gaseste_apropiate', {'user_lat': lat, 'user_lon': lon, 'raza_km': raza_km}).execute()
        if not locatii.data: return []

        spalatorii_ids = [s['id'] for s in locatii.data]
        now = datetime.now(timezone.utc)
        end_window = now + timedelta(hours=2)

        # 2. Fetch Data
        boxe_all = supabase.table('boxe').select('*').in_('spalatorie_id', spalatorii_ids).eq('is_available', True).execute()
        rezervari_all = supabase.table('rezervari').select('*').in_('spalatorie_id', spalatorii_ids).eq('status', 'activa').gte('ora_sfarsit', now.isoformat()).lte('ora_start', end_window.isoformat()).execute()

        rezultat_final = []

        # 3. Procesare
        for loc in locatii.data:
            program = loc.get('program_functionare', "00:00 - 24:00") or "00:00 - 24:00"
            boxe_locatie = [b for b in boxe_all.data if b['spalatorie_id'] == loc['id']]
            boxe_cu_gaps = []

            for boxa in boxe_locatie:
                rez_boxa = [r for r in rezervari_all.data if r['boxa_id'] == boxa['boxa_id']]
                gaps = calculeaza_gaps(now, end_window, rez_boxa, durata_dorita_min, program_str=program)
                if gaps:
                    boxe_cu_gaps.append({
                        "boxa_id": boxa['boxa_id'],
                        "nume_boxa": boxa['nume_boxa'],
                        "pret_rezervare_lei": boxa['pret_rezervare_lei'],
                        "intervale": gaps
                    })
            
            if boxe_cu_gaps:
                rezultat_final.append({
                    "spalatorie_id": loc['id'],
                    "nume": loc['nume'],
                    
                    # --- LINII NOI PENTRU MAPARE ---
                    "program_functionare": program,
                    "latitudine": loc['latitudine'],   # LuÄƒm din RPC
                    "longitudine": loc['longitudine'], # LuÄƒm din RPC
                    # -------------------------------
                    
                    "distanta_km": loc['distanta_km'],
                    "boxe_libere": boxe_cu_gaps
                })

        return rezultat_final
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# --- B. BOXE (CRUD) ---

@app.get("/spalatorii/{spalatorie_id}/boxe", response_model=List[BoxaResponse])
def get_boxe_spalatorie(spalatorie_id: str):
    try:
        return supabase.table('boxe').select('*').eq('spalatorie_id', spalatorie_id).execute().data
    except Exception as e: raise HTTPException(500, str(e))

@app.post("/spalatorii/{spalatorie_id}/boxe", status_code=201)
def adauga_boxa(spalatorie_id: str, boxa: BoxaCreate = Body(...)):
    try:
        d = boxa.model_dump(); d['spalatorie_id'] = spalatorie_id
        return supabase.table('boxe').insert(d).execute().data[0]
    except Exception as e: raise HTTPException(500, str(e))

@app.patch("/spalatorii/{spalatorie_id}/boxe/{boxa_id}")
def update_boxa(spalatorie_id: str, boxa_id: str, u: BoxaUpdate):
    try:
        return supabase.table('boxe').update(u.model_dump(exclude_unset=True)).eq('boxa_id', boxa_id).execute().data[0]
    except Exception as e: raise HTTPException(500, str(e))

@app.delete("/spalatorii/{spalatorie_id}/boxe/{boxa_id}", status_code=204)
def sterge_boxa(spalatorie_id: str, boxa_id: str):
    try:
        supabase.table('boxe').delete().eq('boxa_id', boxa_id).execute()
    except Exception as e: raise HTTPException(500, str(e))

# --- C. REZERVÄ‚RI (NO AUTH) ---

@app.post("/rezervari", status_code=status.HTTP_201_CREATED, response_model=RezervareResponse)
def creare_rezervare(rezervare: RezervareCreate):
    try:
        # 1. AflÄƒm locaÈ›ia
        boxa_info = supabase.table('boxe').select('spalatorie_id').eq('boxa_id', rezervare.boxa_id).execute()
        if not boxa_info.data:
            raise HTTPException(status_code=404, detail="Boxa nu existÄƒ.")
        real_spalatorie_id = boxa_info.data[0]['spalatorie_id']

        # 2. CalculÄƒm timpii
        start = datetime.now(timezone.utc)
        sfarsit = start + timedelta(minutes=rezervare.durata_minute)
        
        # 3. InserÄƒm (FÄƒrÄƒ user_id, doar client_ref)
        data_insert = {
            "boxa_id": rezervare.boxa_id,
            "spalatorie_id": real_spalatorie_id,
            "ora_start": start.isoformat(),
            "ora_sfarsit": sfarsit.isoformat(),
            "client_ref": rezervare.client_ref,
            "status": "activa"
        }
        response = supabase.table('rezervari').insert(data_insert).execute()
        if response.data: return response.data[0]
        raise HTTPException(status_code=500, detail="Eroare server.")

    except Exception as e:
        if "conflict" in str(e).lower() or "exclusion" in str(e).lower():
            raise HTTPException(status_code=409, detail="Boxa este deja ocupatÄƒ!")
        raise HTTPException(status_code=500, detail=str(e))

@app.patch("/rezervari/{rezervare_id}/checkout")
def early_checkout(rezervare_id: str):
    try:
        now = datetime.now(timezone.utc).isoformat()
        r = supabase.table('rezervari').update({"ora_sfarsit": now, "status": "finalizata"}).eq('rezervare_id', rezervare_id).execute()
        if r.data: return r.data[0]
        raise HTTPException(404, "Nu existÄƒ")
    except Exception as e: raise HTTPException(500, str(e))

# --- D. Disponibilitate DetaliatÄƒ ---
@app.get("/spalatorii/{spalatorie_id}/disponibilitate", response_model=List[BoxaDisponibila])
def get_disponibilitate_spalatorie(
    spalatorie_id: str,
    durata_dorita_min: int = 30,
    fereastra_ore: int = 2
):
    try:
        now = datetime.now(timezone.utc)
        end_window = now + timedelta(hours=fereastra_ore)
        
        spalatorie = supabase.table('spalatorii').select('program_functionare').eq('id', spalatorie_id).execute()
        program = "00:00 - 24:00"
        if spalatorie.data:
            program = spalatorie.data[0].get('program_functionare', "00:00 - 24:00") or "00:00 - 24:00"

        boxe = supabase.table('boxe').select('*').eq('spalatorie_id', spalatorie_id).eq('is_available', True).execute()
        if not boxe.data: return []

        rezervari = supabase.table('rezervari').select('*').eq('spalatorie_id', spalatorie_id).eq('status', 'activa').gte('ora_sfarsit', now.isoformat()).lte('ora_start', end_window.isoformat()).execute()
        
        rezultat = []
        for boxa in boxe.data:
            rez_boxa = [r for r in rezervari.data if r['boxa_id'] == boxa['boxa_id']]
            gaps = calculeaza_gaps(now, end_window, rez_boxa, durata_dorita_min, program_str=program)
            if gaps:
                rezultat.append({
                    "boxa_id": boxa['boxa_id'],
                    "nume_boxa": boxa['nume_boxa'],
                    "pret_rezervare_lei": boxa['pret_rezervare_lei'],
                    "intervale": gaps
                })
        return rezultat
    except Exception as e: raise HTTPException(500, str(e))

# ---------------------------
# D. ADMIN & ISTORIC (Rute Noi)
# ---------------------------

@app.get("/rezervari", response_model=List[RezervareResponse], summary="Toate RezervÄƒrile (Admin)")
def get_toate_rezervarile(
    client_ref: Optional[str] = Query(None, description="FiltreazÄƒ dupÄƒ nr. telefon/auto")
):
    """
    ReturneazÄƒ lista tuturor rezervÄƒrilor din sistem.
    OpÈ›ional: poÈ›i filtra dupÄƒ un client specific.
    """
    try:
        query = supabase.table('rezervari').select('*')
        
        # DacÄƒ am primit un client_ref, filtrÄƒm (Istoric Client)
        if client_ref:
            query = query.eq('client_ref', client_ref)
            
        # OrdonÄƒm descrescÄƒtor (cele mai noi primele)
        response = query.order('ora_start', desc=True).execute()
        
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/spalatorii/{spalatorie_id}/rezervari", response_model=List[RezervareResponse], summary="RezervÄƒri per SpÄƒlÄƒtorie")
def get_rezervari_spalatorie(
    spalatorie_id: str,
    doar_active: bool = Query(False, description="DacÄƒ true, aratÄƒ doar ce urmeazÄƒ")
):
    """
    ReturneazÄƒ toate rezervÄƒrile pentru o anumitÄƒ spÄƒlÄƒtorie.
    Util pentru dashboard-ul proprietarului.
    """
    try:
        query = supabase.table('rezervari').select('*').eq('spalatorie_id', spalatorie_id)
        
        if doar_active:
            # AratÄƒ doar ce nu a expirat Ã®ncÄƒ
            now = datetime.now(timezone.utc).isoformat()
            query = query.eq('status', 'activa').gte('ora_sfarsit', now)
            
        response = query.order('ora_start', desc=True).execute()
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


================================================
FILE: mainV3.py
================================================
import os
import re
from fastapi import FastAPI, HTTPException, Query, Body, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, field_validator
from typing import List, Optional
from dotenv import load_dotenv
from supabase import create_client, Client
from datetime import datetime, timedelta, timezone
from fastapi.middleware.cors import CORSMiddleware

# --- 1. CONFIGURARE & CONEXIUNE ---
load_dotenv()

app = FastAPI(
    title="QuickWash MVP",
    description="Backend Final: Supabase Auth + Rezervare Smart + Night Owl Fix"
)

# CORS - Permitem Frontend-ul
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

SUPABASE_URL: str = os.environ.get("SUPABASE_URL")
SUPABASE_KEY: str = os.environ.get("SUPABASE_KEY")

if not SUPABASE_URL or not SUPABASE_KEY:
    raise RuntimeError("SUPABASE_URL sau SUPABASE_KEY lipsesc din fiÈ™ierul .env")

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# --- SECURITATE (Portarul) ---
# AceastÄƒ componentÄƒ este nouÄƒ È™i criticÄƒ pentru Auth
security = HTTPBearer()

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """ 
    VerificÄƒ token-ul JWT trimis de Frontend.
    ReturneazÄƒ obiectul User din Supabase sau dÄƒ eroare 401.
    """
    token = credentials.credentials
    try:
        user_response = supabase.auth.get_user(token)
        if not user_response.user:
            raise HTTPException(status_code=401, detail="Token invalid sau expirat.")
        return user_response.user
    except Exception:
        raise HTTPException(status_code=401, detail="Trebuie sÄƒ fii logat.")


# ==========================================
# 2. MODELE DE DATE (Pydantic Schemas)
# ==========================================

# --- SpÄƒlÄƒtorii ---
class SpalatorieCreate(BaseModel):
    nume: str
    adresa: Optional[str] = None
    program_functionare: str = "00:00 - 24:00"
    latitudine: float
    longitudine: float

    @field_validator('program_functionare')
    @classmethod
    def validate_program(cls, v: str) -> str:
        if "non" in v.lower() and "stop" in v.lower():
            return "00:00 - 24:00"
        pattern = r"^\d{2}:\d{2}\s*-\s*\d{2}:\d{2}$"
        if not re.match(pattern, v.strip()):
            raise ValueError('Format invalid! FoloseÈ™te "HH:MM - HH:MM"')
        return v

# --- Boxe ---
class BoxaBase(BaseModel):
    nume_boxa: str
    pret_rezervare_lei: float = 15.0
    timp_rezervare_minute: int = 60
    is_available: bool = True

class BoxaCreate(BoxaBase):
    pass

class BoxaUpdate(BaseModel):
    nume_boxa: Optional[str] = None
    pret_rezervare_lei: Optional[float] = None
    timp_rezervare_minute: Optional[int] = None
    is_available: Optional[bool] = None

class BoxaResponse(BoxaBase):
    boxa_id: str
    spalatorie_id: str

# --- RezervÄƒri (Actualizat pentru Auth) ---
class RezervareCreate(BaseModel):
    boxa_id: str
    durata_minute: int 
    # client_ref a fost eliminat, ID-ul vine din Token

class RezervareResponse(BaseModel):
    rezervare_id: str
    boxa_id: str
    spalatorie_id: str
    ora_start: datetime
    ora_sfarsit: datetime
    status: str
    # MODIFICARE CRITICÄ‚: client_ref e optional acum, user_id e nou
    user_id: Optional[str] = None
    client_ref: Optional[str] = None 

# --- Modele Disponibilitate ---
class IntervalLiber(BaseModel):
    start: datetime
    end: datetime
    minute_disponibile: int

class BoxaDisponibila(BaseModel):
    boxa_id: str
    nume_boxa: str
    pret_rezervare_lei: float
    intervale: List[IntervalLiber]

class SpalatorieDisponibilaResponse(BaseModel):
    spalatorie_id: str
    nume: str
    program_functionare: str
    distanta_km: Optional[float] = None
    latitudine: float
    longitudine: float
    boxe_libere: List[BoxaDisponibila]


# ==========================================
# 3. LOGICA DE BUSINESS (Algoritmul Night Owl)
# ==========================================

def parse_schedule(schedule_str: str):
    if not schedule_str or "00:00 - 24:00" in schedule_str:
        return 0, 24
    try:
        parts = schedule_str.split('-')
        return int(parts[0].strip().split(':')[0]), int(parts[1].strip().split(':')[0])
    except:
        return 0, 24 

def calculeaza_gaps(start_window_utc, end_window_utc, rezervari, durata_minima_minute, program_str="00:00 - 24:00"):
    # Aceasta este versiunea V5 (Night Owl Fix) pe care ai cerut-o
    gaps = []
    RO_OFFSET = timezone(timedelta(hours=2)) 
    now_ro = start_window_utc.astimezone(RO_OFFSET)
    
    ora_deschidere, ora_inchidere = parse_schedule(program_str)
    
    open_intervals = []
    if ora_deschidere < ora_inchidere:
        open_intervals.append((ora_deschidere, ora_inchidere))
    elif ora_deschidere > ora_inchidere:
        open_intervals.append((0, ora_inchidere))
        open_intervals.append((ora_deschidere, 24))
    else:
        open_intervals.append((0, 24))

    adjusted_start_utc = None
    current_hour = now_ro.hour + (now_ro.minute / 60)
    is_open_now = False
    next_open_hour = None
    current_closing_hour = 24

    for (start_h, end_h) in open_intervals:
        if start_h <= current_hour < end_h:
            is_open_now = True
            current_closing_hour = end_h
            break
        if start_h > current_hour:
            if next_open_hour is None or start_h < next_open_hour:
                next_open_hour = start_h
                current_closing_hour = end_h

    if is_open_now:
        adjusted_start_utc = start_window_utc
    elif next_open_hour is not None:
        target_h = int(next_open_hour)
        target_m = int((next_open_hour - target_h) * 60)
        start_ro_adjusted = now_ro.replace(hour=target_h, minute=target_m, second=0)
        adjusted_start_utc = start_ro_adjusted.astimezone(timezone.utc)
    else:
        return []

    if adjusted_start_utc >= end_window_utc:
        return []

    current_time = adjusted_start_utc
    rezervari_sorted = sorted(rezervari, key=lambda x: datetime.fromisoformat(x['ora_start']))

    for res in rezervari_sorted:
        res_start = datetime.fromisoformat(res['ora_start'])
        res_end = datetime.fromisoformat(res['ora_sfarsit'])

        if res_start > current_time:
            gap_start_ro = current_time.astimezone(RO_OFFSET)
            limit_end = res_start
            
            if current_closing_hour != 24:
                h_close = int(current_closing_hour)
                m_close = int((current_closing_hour - h_close) * 60)
                ora_inchidere_azi_ro = gap_start_ro.replace(hour=h_close, minute=m_close, second=0)
                ora_inchidere_azi_utc = ora_inchidere_azi_ro.astimezone(timezone.utc)
                if limit_end > ora_inchidere_azi_utc:
                    limit_end = ora_inchidere_azi_utc
            
            if limit_end > current_time:
                gap_duration = (limit_end - current_time).total_seconds() / 60
                if gap_duration >= durata_minima_minute:
                    gaps.append({"start": current_time, "end": limit_end, "minute_disponibile": int(gap_duration)})

        if res_end > current_time:
            current_time = res_end

    if current_time < end_window_utc:
        limit_end = end_window_utc
        gap_start_ro = current_time.astimezone(RO_OFFSET)
        if current_closing_hour != 24:
            h_close = int(current_closing_hour)
            m_close = int((current_closing_hour - h_close) * 60)
            ora_inchidere_azi_ro = gap_start_ro.replace(hour=h_close, minute=m_close, second=0)
            ora_inchidere_azi_utc = ora_inchidere_azi_ro.astimezone(timezone.utc)
            if limit_end > ora_inchidere_azi_utc:
                limit_end = ora_inchidere_azi_utc
        
        if limit_end > current_time:
            gap_duration = (limit_end - current_time).total_seconds() / 60
            if gap_duration >= durata_minima_minute:
                gaps.append({"start": current_time, "end": limit_end, "minute_disponibile": int(gap_duration)})
            
    return gaps


# ==========================================
# 4. RUTE API (Endpoints)
# ==========================================

@app.get("/", summary="Health Check")
def read_root():
    return {"status": "QuickWash API este live!"}

# --- A. SPÄ‚LÄ‚TORII ---

@app.post("/spalatorii", status_code=status.HTTP_201_CREATED)
def add_spalatorie(spalatorie: SpalatorieCreate = Body(...)):
    try:
        data = spalatorie.model_dump()
        response = supabase.table('spalatorii').insert({
            "nume": data['nume'],
            "adresa": data['adresa'],
            "program_functionare": data['program_functionare'],
            "locatie": f"SRID=4326;POINT({data['longitudine']} {data['latitudine']})"
        }).execute()
        if response.data: return response.data[0]
        raise HTTPException(status_code=500, detail="Eroare salvare.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/spalatorii-apropiate/disponibilitate", response_model=List[SpalatorieDisponibilaResponse])
def get_spalatorii_apropiate_disponibile(
    lat: float, lon: float, raza_km: float = 5.0, durata_dorita_min: int = 30
):
    try:
        locatii = supabase.rpc(
            'get_spalatorii_apropiate', 
            {
                'lat_user': lat, 
                'lon_user': lon, 
                'raza_km': raza_km
            }
        ).execute()
        if not locatii.data: return []

        spalatorii_ids = [s['id'] for s in locatii.data]
        now = datetime.now(timezone.utc)
        end_window = now + timedelta(hours=2)

        boxe_all = supabase.table('boxe').select('*').in_('spalatorie_id', spalatorii_ids).eq('is_available', True).execute()
        rezervari_all = supabase.table('rezervari').select('*').in_('spalatorie_id', spalatorii_ids).eq('status', 'activa').gte('ora_sfarsit', now.isoformat()).lte('ora_start', end_window.isoformat()).execute()

        rezultat_final = []
        for loc in locatii.data:
            program = loc.get('program_functionare', "00:00 - 24:00") or "00:00 - 24:00"
            boxe_locatie = [b for b in boxe_all.data if b['spalatorie_id'] == loc['id']]
            boxe_cu_gaps = []

            for boxa in boxe_locatie:
                rez_boxa = [r for r in rezervari_all.data if r['boxa_id'] == boxa['boxa_id']]
                gaps = calculeaza_gaps(now, end_window, rez_boxa, durata_dorita_min, program_str=program)
                if gaps:
                    boxe_cu_gaps.append({
                        "boxa_id": boxa['boxa_id'],
                        "nume_boxa": boxa['nume_boxa'],
                        "pret_rezervare_lei": boxa['pret_rezervare_lei'],
                        "intervale": gaps
                    })
            
            if boxe_cu_gaps:
                rezultat_final.append({
                    "spalatorie_id": loc['id'],
                    "nume": loc['nume'],
                    "program_functionare": program,
                    "latitudine": loc['latitudine'],
                    "longitudine": loc['longitudine'],
                    "distanta_km": loc['distanta_km'],
                    "boxe_libere": boxe_cu_gaps
                })

        return rezultat_final
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# --- B. BOXE (CRUD) ---

@app.get("/spalatorii/{spalatorie_id}/boxe", response_model=List[BoxaResponse])
def get_boxe_spalatorie(spalatorie_id: str):
    try:
        return supabase.table('boxe').select('*').eq('spalatorie_id', spalatorie_id).execute().data
    except Exception as e: raise HTTPException(500, str(e))

@app.post("/spalatorii/{spalatorie_id}/boxe", status_code=201)
def adauga_boxa(spalatorie_id: str, boxa: BoxaCreate = Body(...)):
    try:
        d = boxa.model_dump(); d['spalatorie_id'] = spalatorie_id
        return supabase.table('boxe').insert(d).execute().data[0]
    except Exception as e: raise HTTPException(500, str(e))

@app.patch("/spalatorii/{spalatorie_id}/boxe/{boxa_id}")
def update_boxa(spalatorie_id: str, boxa_id: str, u: BoxaUpdate):
    try:
        return supabase.table('boxe').update(u.model_dump(exclude_unset=True)).eq('boxa_id', boxa_id).execute().data[0]
    except Exception as e: raise HTTPException(500, str(e))

@app.delete("/spalatorii/{spalatorie_id}/boxe/{boxa_id}", status_code=204)
def sterge_boxa(spalatorie_id: str, boxa_id: str):
    try:
        supabase.table('boxe').delete().eq('boxa_id', boxa_id).execute()
    except Exception as e: raise HTTPException(500, str(e))

# --- C. REZERVÄ‚RI (SECURIZE CU AUTH) ---

@app.post("/rezervari", status_code=status.HTTP_201_CREATED, response_model=RezervareResponse)
def creare_rezervare(
    rezervare: RezervareCreate, 
    user = Depends(get_current_user) # NecesitÄƒ Login
):
    try:
        # 1. AflÄƒm locaÈ›ia
        boxa_info = supabase.table('boxe').select('spalatorie_id').eq('boxa_id', rezervare.boxa_id).execute()
        if not boxa_info.data:
            raise HTTPException(status_code=404, detail="Boxa nu existÄƒ.")
        real_spalatorie_id = boxa_info.data[0]['spalatorie_id']

        # 2. CalculÄƒm timpii
        start = datetime.now(timezone.utc)
        sfarsit = start + timedelta(minutes=rezervare.durata_minute)
        
        # 3. InserÄƒm (folosind user.id din token)
        data_insert = {
            "boxa_id": rezervare.boxa_id,
            "spalatorie_id": real_spalatorie_id,
            "ora_start": start.isoformat(),
            "ora_sfarsit": sfarsit.isoformat(),
            "user_id": user.id,      
            "status": "activa"
        }
        
        response = supabase.table('rezervari').insert(data_insert).execute()
        
        if response.data: 
            rezultat = response.data[0]
            # AdÄƒugÄƒm email-ul pentru frontend
            rezultat['client_ref'] = user.email 
            return rezultat
            
        raise HTTPException(status_code=500, detail="Eroare server.")

    except Exception as e:
        if "conflict" in str(e).lower() or "exclusion" in str(e).lower():
            raise HTTPException(status_code=409, detail="Boxa este deja ocupatÄƒ!")
        raise HTTPException(status_code=500, detail=str(e))

@app.patch("/rezervari/{rezervare_id}/checkout")
def early_checkout(rezervare_id: str):
    try:
        now = datetime.now(timezone.utc).isoformat()
        r = supabase.table('rezervari').update({"ora_sfarsit": now, "status": "finalizata"}).eq('rezervare_id', rezervare_id).execute()
        if r.data: return r.data[0]
        raise HTTPException(404, "Nu existÄƒ")
    except Exception as e: raise HTTPException(500, str(e))

# --- D. ISTORIC (SECURIZE CU AUTH) ---

@app.get("/rezervari", response_model=List[RezervareResponse], summary="Istoricul Meu")
def get_rezervari_mele(user = Depends(get_current_user)):
    """
    ReturneazÄƒ doar rezervÄƒrile utilizatorului logat curent.
    Se foloseÈ™te token-ul pentru identificare, nu un parametru URL.
    """
    try:
        response = supabase.table('rezervari').select('*')\
            .eq('user_id', user.id)\
            .order('ora_start', desc=True)\
            .execute()
        
        # Facem compatibilitate cu frontend-ul dacÄƒ se aÈ™teaptÄƒ la client_ref
        data = response.data
        for item in data:
            if 'client_ref' not in item or item['client_ref'] is None:
                item['client_ref'] = user.email
                
        return data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/spalatorii/{spalatorie_id}/rezervari", response_model=List[RezervareResponse], summary="Admin SpÄƒlÄƒtorie")
def get_rezervari_spalatorie(
    spalatorie_id: str,
    doar_active: bool = Query(False)
):
    # AceastÄƒ rutÄƒ va fi securizatÄƒ ulterior pentru OWNER
    try:
        query = supabase.table('rezervari').select('*').eq('spalatorie_id', spalatorie_id)
        if doar_active:
            now = datetime.now(timezone.utc).isoformat()
            query = query.eq('status', 'activa').gte('ora_sfarsit', now)
            
        response = query.order('ora_start', desc=True).execute()
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


================================================
FILE: requirements.txt
================================================
[Binary file]

